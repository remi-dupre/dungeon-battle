The game is structured around the `Game` class. This class runs the main loop of the game with the function `Game::run()`.
Each iteration we check if the game needs an update and call `Game::update` accordingly, and we call `Game::render()` to render the game.

Edit, build and release
=======================

We use git for versioning, the project is hosted on [github](https://github.com/remi-dupre/dungeon-battle).

When editing the code, we (try to) follow a coding style defined in [CODING_STYLE.md](https://github.com/remi-dupre/dungeon-battle/blob/master/CODING_STYLE.md).

The makefile provides severals targets:

 - `debug` to test the game with debbuging information
 - `release` to make a release of the game
 - `warnings` to list more warnings generated by g++ (without compiling)
 - `profiling` to generated an optimized version used to profile
 - `tests` to build and run tests
 - `lint` to generate more warnings with the linter `cppcheck`
 - `doc` to generate the documentation

When implementing any changes in the code, you should at least test if it builds in `debug`, and runs without immediatly crashing.
When you have tested the code, you can push your changes to `github`, a continuous integration system will try to build and run some tests. If it fails, you should fix the issues as quickly as possible.


Map & procedural generation
===========================

The map is handled by the `Map` class, and the generation module is located in the `generation/` subfolder.

Entity system
=============

We use an entity system to handle entities of the game (the hero, monsters, object, and items).
The base class `Entity` represents a basic entity, where the derived classes `Character` and `Item` are used for the hero and monsters, and items respectively. These classes defines all the functions used to manipulate entities.

Rendering
=========

The rendering module is centered on the class `Renderer`, which handles all the SFML ressources and draws the game.
The function
```cpp
void drawGame(const Map& map,
              MapExploration& map_exploration,
              const std::vector<std::shared_ptr<Entity>>& entities,
              std::shared_ptr<Entity> center_entity,
              float frame_progress)
```
is used to perform all the pre-computations of the rendering (i.e. filling a array with vertices).
Its arguments are:

 - `const Map& map`
   the map to draw
 - `MapExploration& map_exploration`
   the exploration state of the map (**it is updated in this function**)
 - `const std::vector<std::shared_ptr<Entity>>& entities`
   the array of entities
 - `std::shared_ptr<Entity> center_entity`
   the entity to center the screen on
 - `float frame_progress`
   the turn progress

The actual rendering is done with the function
```cpp
void display(sf::RenderTarget& target, float frame_progress)
```

Menus
=====

The menus are defined in the files in the `menu/` subfolder. The `Game` class keeps a (smart) pointer to a menu, and update it if it exists.
A new menu should inherit from the `Menu` class and overload the following functions:
  - `Menu::update()` (unused for the moment)
  - `void handleInput(const sf::Event& event, const Configuration& config)`
    which is used to pass an event to the menu
  - `MenuEvent menuEvent()` which returns the next action to do: nothing, change menu, save a game, close the menu,...
  - `bool displayGame()` which returns true iff the game should be displayed behind the menu
  - `void render(sf::RenderTarget& target)` which should render the menu on `target`
Moreover the base menu defines a variable `bool select_key_pressed` which should be used to tell if an item in the menu was selected (and confirmed with the `return` key)